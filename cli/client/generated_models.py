# generated by datamodel-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-11-25T10:10:03+00:00

from __future__ import annotations

from enum import Enum
from typing import Annotated, Any
from uuid import UUID

from pydantic import AnyUrl, AwareDatetime, BaseModel, ConfigDict, Field, RootModel


class PromptRequest(BaseModel):
    prompt: Annotated[
        dict[str, Any], Field(description='The workflow graph to execute')
    ]
    number: Annotated[
        float | None,
        Field(
            description='Priority number for the queue (lower numbers have higher priority)'
        ),
    ] = None
    front: Annotated[
        bool | None,
        Field(description='If true, adds the prompt to the front of the queue'),
    ] = None
    extra_data: Annotated[
        dict[str, Any] | None,
        Field(description='Extra data to be associated with the prompt'),
    ] = None
    partial_execution_targets: Annotated[
        list[str] | None, Field(description='List of node names to execute')
    ] = None


class PromptResponse(BaseModel):
    prompt_id: Annotated[
        UUID | None, Field(description='Unique identifier for the prompt execution')
    ] = None
    number: Annotated[
        float | None, Field(description='Priority number in the queue')
    ] = None
    node_errors: Annotated[
        dict[str, Any] | None,
        Field(description='Any errors in the nodes of the prompt'),
    ] = None


class ErrorResponse(BaseModel):
    code: str
    message: str


class ExecInfo(BaseModel):
    queue_remaining: Annotated[
        int | None, Field(description='Number of items remaining in the queue')
    ] = None


class PromptInfo(BaseModel):
    exec_info: ExecInfo | None = None


class NodeInfo(BaseModel):
    input: Annotated[
        dict[str, Any] | None, Field(description='Input specifications for the node')
    ] = None
    input_order: Annotated[
        dict[str, list[str]] | None, Field(description='Order of inputs for display')
    ] = None
    output: Annotated[
        list[str] | None, Field(description='Output types of the node')
    ] = None
    output_is_list: Annotated[
        list[bool] | None, Field(description='Whether each output is a list')
    ] = None
    output_name: Annotated[
        list[str] | None, Field(description='Names of the outputs')
    ] = None
    name: Annotated[str | None, Field(description='Internal name of the node')] = None
    display_name: Annotated[
        str | None, Field(description='Display name of the node')
    ] = None
    description: Annotated[str | None, Field(description='Description of the node')] = (
        None
    )
    python_module: Annotated[
        str | None, Field(description='Python module implementing the node')
    ] = None
    category: Annotated[str | None, Field(description='Category of the node')] = None
    output_node: Annotated[
        bool | None, Field(description='Whether this is an output node')
    ] = None
    output_tooltips: Annotated[
        list[str] | None, Field(description='Tooltips for outputs')
    ] = None
    deprecated: Annotated[
        bool | None, Field(description='Whether the node is deprecated')
    ] = None
    experimental: Annotated[
        bool | None, Field(description='Whether the node is experimental')
    ] = None
    api_node: Annotated[
        bool | None, Field(description='Whether this is an API node')
    ] = None


class Prompt(BaseModel):
    priority: Annotated[float | None, Field(description='Execution priority')] = None
    prompt_id: Annotated[str | None, Field(description='The prompt ID')] = None
    extra_data: Annotated[
        dict[str, Any] | None,
        Field(
            description='Additional execution data (workflow removed from extra_pnginfo)'
        ),
    ] = None


class HistoryEntry(BaseModel):
    prompt_id: Annotated[
        str, Field(description='Unique identifier for this prompt execution')
    ]
    create_time: Annotated[
        int | None,
        Field(description='Job creation timestamp (Unix timestamp in milliseconds)'),
    ] = None
    prompt: Annotated[
        Prompt | None,
        Field(description='Filtered prompt execution data (lightweight format)'),
    ] = None
    outputs: Annotated[
        dict[str, Any] | None,
        Field(description='Output data from execution (generated images, files, etc.)'),
    ] = None
    status: Annotated[
        dict[str, Any] | None,
        Field(description='Execution status and timeline information'),
    ] = None
    meta: Annotated[
        dict[str, Any] | None,
        Field(description='Metadata about the execution and nodes'),
    ] = None
    workflow_id: Annotated[
        str | None, Field(description='UUID identifying the workflow graph definition')
    ] = None


class Prompt1(BaseModel):
    priority: Annotated[float | None, Field(description='Execution priority')] = None
    prompt_id: Annotated[str | None, Field(description='The prompt ID')] = None
    prompt: Annotated[
        dict[str, Any] | None, Field(description='The workflow nodes')
    ] = None
    extra_data: Annotated[
        dict[str, Any] | None, Field(description='Additional execution data')
    ] = None
    outputs_to_execute: Annotated[
        list[str] | None, Field(description='Output nodes to execute')
    ] = None


class HistoryDetailEntry(BaseModel):
    prompt: Annotated[
        Prompt1 | None, Field(description='Full prompt execution data')
    ] = None
    outputs: Annotated[
        dict[str, Any] | None,
        Field(description='Output data from execution (generated images, files, etc.)'),
    ] = None
    status: Annotated[
        dict[str, Any] | None,
        Field(description='Execution status and timeline information'),
    ] = None
    meta: Annotated[
        dict[str, Any] | None,
        Field(description='Metadata about the execution and nodes'),
    ] = None


class HistoryDetailResponse(RootModel[dict[str, HistoryDetailEntry]]):
    root: dict[str, HistoryDetailEntry]


class QueueInfo(BaseModel):
    queue_running: Annotated[
        list[list] | None, Field(description='Array of currently running job items')
    ] = None
    queue_pending: Annotated[
        list[list] | None,
        Field(
            description='Array of pending job items (ordered by creation time, oldest first)'
        ),
    ] = None


class QueueManageRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    delete: Annotated[
        list[str] | None, Field(description='Array of PENDING job IDs to cancel')
    ] = None
    clear: Annotated[
        bool | None, Field(description='If true, clear all pending jobs from the queue')
    ] = None


class QueueManageResponse(BaseModel):
    deleted: Annotated[
        list[str] | None,
        Field(description='Array of job IDs that were successfully cancelled'),
    ] = None
    cleared: Annotated[
        bool | None, Field(description='Whether the queue was cleared')
    ] = None


class Status(Enum):
    waiting_to_dispatch = 'waiting_to_dispatch'
    pending = 'pending'
    in_progress = 'in_progress'
    completed = 'completed'
    error = 'error'
    cancelled = 'cancelled'


class JobStatusResponse(BaseModel):
    id: Annotated[UUID, Field(description='The job ID')]
    status: Annotated[Status, Field(description='Current job status')]
    created_at: Annotated[AwareDatetime, Field(description='When the job was created')]
    updated_at: Annotated[
        AwareDatetime, Field(description='When the job was last updated')
    ]
    last_state_update: Annotated[
        AwareDatetime | None, Field(description='When the job status was last changed')
    ] = None
    assigned_inference: Annotated[
        str | None,
        Field(description='The inference instance assigned to this job (if any)'),
    ] = None
    error_message: Annotated[
        str | None, Field(description='Error message if the job failed')
    ] = None


class HistoryManageRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    delete: Annotated[
        list[str] | None, Field(description='Array of job IDs to delete from history')
    ] = None
    clear: Annotated[
        bool | None,
        Field(description='If true, clear all history for the authenticated user'),
    ] = None


class UserDataResponseFull(BaseModel):
    path: str | None = None
    size: int | None = None
    modified: AwareDatetime | None = None


class GetUserDataResponseFullFile(BaseModel):
    path: Annotated[
        str | None,
        Field(description='File name or path relative to the user directory.'),
    ] = None
    size: Annotated[int | None, Field(description='File size in bytes.')] = None
    modified: Annotated[
        float | None, Field(description='UNIX timestamp of the last modification.')
    ] = None


class PromptErrorResponse(BaseModel):
    pass
    model_config = ConfigDict(
        extra='allow',
    )


class ModelFolder(BaseModel):
    name: Annotated[
        str, Field(description='The name of the model folder', examples=['checkpoints'])
    ]
    folders: Annotated[
        list[str],
        Field(
            description='List of paths where models of this type are stored',
            examples=[['checkpoints']],
        ),
    ]


class ModelFile(BaseModel):
    name: Annotated[
        str,
        Field(description='The filename of the model', examples=['model.safetensors']),
    ]
    pathIndex: Annotated[
        int,
        Field(
            description='Index of the path where this model is located', examples=[0]
        ),
    ]


class Type(Enum):
    missing_nodes = 'missing_nodes'
    general = 'general'
    missing_models = 'missing_models'


class FeedbackRequest(BaseModel):
    type: Annotated[Type, Field(description='Type of feedback being submitted')]
    content: Annotated[
        str | None, Field(description='The feedback content or message')
    ] = None
    rating: Annotated[
        int | None,
        Field(
            description="User's rating of ComfyUI Cloud experience (1-5 stars)",
            ge=1,
            le=5,
        ),
    ] = None
    metadata: Annotated[
        dict[str, Any] | None,
        Field(description='Additional metadata about the feedback'),
    ] = None


class FeedbackResponse(BaseModel):
    pass


class Level(Enum):
    debug = 'debug'
    info = 'info'
    warn = 'warn'
    error = 'error'


class LogsResponseItem(BaseModel):
    timestamp: Annotated[
        AwareDatetime | None, Field(description='When the log entry was created')
    ] = None
    level: Annotated[Level | None, Field(description='Log level')] = None
    message: Annotated[str | None, Field(description='Log message')] = None
    source: Annotated[str | None, Field(description='Source of the log entry')] = None
    metadata: Annotated[
        dict[str, Any] | None, Field(description='Additional log metadata')
    ] = None


class LogsResponse(RootModel[list[LogsResponseItem]]):
    root: Annotated[list[LogsResponseItem], Field(description='System logs response')]


class Entry(BaseModel):
    m: Annotated[str | None, Field(description='Log message')] = None


class Size(BaseModel):
    cols: Annotated[int | None, Field(description='Terminal column size')] = None
    rows: Annotated[int | None, Field(description='Terminal row size')] = None


class RawLogsResponse(BaseModel):
    entries: list[Entry] | None = None
    size: Size | None = None


class LogsSubscribeRequest(BaseModel):
    enabled: Annotated[
        bool, Field(description='Whether to enable or disable log subscription')
    ]


class System(BaseModel):
    os: Annotated[str, Field(description='Operating system')]
    python_version: Annotated[str, Field(description='Python version')]
    embedded_python: Annotated[bool, Field(description='Whether using embedded Python')]
    comfyui_version: Annotated[str, Field(description='ComfyUI version')]
    comfyui_frontend_version: Annotated[
        str | None, Field(description='ComfyUI frontend version (commit hash or tag)')
    ] = None
    workflow_templates_version: Annotated[
        str | None, Field(description='Workflow templates version')
    ] = None
    cloud_version: Annotated[
        str | None, Field(description='Cloud ingest service version (commit hash)')
    ] = None
    pytorch_version: Annotated[str, Field(description='PyTorch version')]
    argv: Annotated[list[str], Field(description='Command line arguments')]
    ram_total: Annotated[float, Field(description='Total RAM in bytes')]
    ram_free: Annotated[float, Field(description='Free RAM in bytes')]


class Device(BaseModel):
    name: Annotated[str, Field(description='Device name')]
    type: Annotated[str, Field(description='Device type')]
    vram_total: Annotated[float | None, Field(description='Total VRAM in bytes')] = None
    vram_free: Annotated[float | None, Field(description='Free VRAM in bytes')] = None


class SystemStatsResponse(BaseModel):
    system: System
    devices: list[Device]


class UserResponse(BaseModel):
    status: Annotated[str, Field(description='User status (active or waitlisted)')]


class CreateSessionRequest(BaseModel):
    idToken: Annotated[str, Field(description='Firebase ID token from the client')]


class CreateSessionResponse(BaseModel):
    success: Annotated[
        bool, Field(description='Whether the session was created successfully')
    ]
    expiresIn: Annotated[
        int | None, Field(description='Session expiration time in seconds (5 days)')
    ] = None


class DeleteSessionResponse(BaseModel):
    success: Annotated[
        bool, Field(description='Whether the session was deleted successfully')
    ]


class InviteCodeStatusResponse(BaseModel):
    claimed: Annotated[bool, Field(description='Whether the code has been claimed')]
    expired: Annotated[bool, Field(description='Whether the code has expired')]


class InviteCodeClaimResponse(BaseModel):
    success: Annotated[bool, Field(description='Whether the claim was successful')]
    message: Annotated[str, Field(description='Success message')]


class SendUserInviteEmailRequest(BaseModel):
    email: Annotated[
        str, Field(description='The email address to send the invitation to')
    ]
    force: Annotated[
        bool | None,
        Field(
            description='Whether to force send the invite even if user already exists or has been invited'
        ),
    ] = False


class SendUserInviteEmailResponse(BaseModel):
    success: Annotated[
        bool, Field(description='Whether the email was sent successfully')
    ]
    message: Annotated[str, Field(description='A message describing the result')]


class FileMappings(RootModel[dict[str, str]]):
    root: Annotated[
        dict[str, str], Field(description='Human readable name for the file')
    ]


class Asset(BaseModel):
    id: Annotated[UUID, Field(description='Unique identifier for the asset')]
    name: Annotated[str, Field(description='Name of the asset file')]
    asset_hash: Annotated[
        str | None,
        Field(
            description='Blake3 hash of the asset content',
            pattern='^blake3:[a-f0-9]{64}$',
        ),
    ] = None
    size: Annotated[int, Field(description='Size of the asset in bytes')]
    mime_type: Annotated[str | None, Field(description='MIME type of the asset')] = None
    tags: Annotated[
        list[str] | None, Field(description='Tags associated with the asset')
    ] = None
    user_metadata: Annotated[
        dict[str, Any] | None, Field(description='Custom user metadata for the asset')
    ] = None
    preview_url: Annotated[
        AnyUrl | None, Field(description='URL for asset preview/thumbnail')
    ] = None
    preview_id: Annotated[
        UUID | None, Field(description='ID of the preview asset if available')
    ] = None
    prompt_id: Annotated[
        UUID | None,
        Field(description='ID of the job/prompt that created this asset, if available'),
    ] = None
    created_at: Annotated[
        AwareDatetime, Field(description='Timestamp when the asset was created')
    ]
    updated_at: Annotated[
        AwareDatetime, Field(description='Timestamp when the asset was last updated')
    ]
    last_access_time: Annotated[
        AwareDatetime | None,
        Field(description='Timestamp when the asset was last accessed'),
    ] = None


class AssetCreated(Asset):
    created_new: Annotated[
        bool,
        Field(
            description='Whether this was a new asset creation (true) or returned existing (false)'
        ),
    ]


class AssetUpdated(BaseModel):
    id: Annotated[UUID, Field(description='Asset ID')]
    name: Annotated[str | None, Field(description='Updated name of the asset')] = None
    asset_hash: Annotated[
        str | None,
        Field(
            description='Blake3 hash of the asset content',
            pattern='^blake3:[a-f0-9]{64}$',
        ),
    ] = None
    tags: Annotated[
        list[str] | None, Field(description='Updated tags for the asset')
    ] = None
    mime_type: Annotated[
        str | None, Field(description='Updated MIME type of the asset')
    ] = None
    user_metadata: Annotated[
        dict[str, Any] | None, Field(description='Updated custom metadata')
    ] = None
    updated_at: Annotated[AwareDatetime, Field(description='Timestamp of the update')]


class ListAssetsResponse(BaseModel):
    assets: Annotated[
        list[Asset], Field(description='List of assets matching the query')
    ]
    total: Annotated[
        int, Field(description='Total number of assets matching the filters')
    ]
    has_more: Annotated[
        bool, Field(description='Whether more assets are available beyond this page')
    ]


class TagInfo(BaseModel):
    name: Annotated[str, Field(description='Tag name')]
    count: Annotated[int, Field(description='Number of assets using this tag')]


class ListTagsResponse(BaseModel):
    tags: Annotated[list[TagInfo], Field(description='List of tags')]
    total: Annotated[int, Field(description='Total number of tags')]
    has_more: Annotated[bool, Field(description='Whether more tags are available')]


class AssetTagHistogramResponse(BaseModel):
    tag_counts: Annotated[
        dict[str, int],
        Field(
            description='Map of tag names to their occurrence counts on matching assets',
            examples=[{'checkpoint': 32, 'lora': 193, 'vae': 6}],
        ),
    ]


class ValidationError(BaseModel):
    code: Annotated[
        str,
        Field(
            description='Machine-readable error code', examples=['FORMAT_NOT_ALLOWED']
        ),
    ]
    message: Annotated[
        str,
        Field(
            description='Human-readable error message',
            examples=[
                'File format "PickleTensor" is not allowed. Allowed formats: [SafeTensor]'
            ],
        ),
    ]
    field: Annotated[
        str, Field(description='Field that failed validation', examples=['format'])
    ]


class TagsModificationResponse(BaseModel):
    added: Annotated[
        list[str] | None,
        Field(description='Tags that were successfully added (for add operation)'),
    ] = None
    removed: Annotated[
        list[str] | None,
        Field(description='Tags that were successfully removed (for remove operation)'),
    ] = None
    already_present: Annotated[
        list[str] | None,
        Field(description='Tags that were already present (for add operation)'),
    ] = None
    not_present: Annotated[
        list[str] | None,
        Field(description='Tags that were not present (for remove operation)'),
    ] = None
    total_tags: Annotated[
        list[str], Field(description='All tags on the asset after the operation')
    ]


class Status1(Enum):
    pending = 'pending'
    in_progress = 'in_progress'
    completed = 'completed'
    failed = 'failed'
    cancelled = 'cancelled'


class JobEntry(BaseModel):
    id: Annotated[UUID, Field(description='Unique job identifier')]
    status: Annotated[Status1, Field(description='User-friendly job status')]
    error_message: Annotated[
        str | None, Field(description='Error message if job failed')
    ] = None
    create_time: Annotated[
        int, Field(description='Job creation timestamp (Unix timestamp in seconds)')
    ]
    preview_output: Annotated[
        dict[str, Any] | None,
        Field(description='Primary preview output (only present for terminal states)'),
    ] = None
    outputs_count: Annotated[
        int | None,
        Field(
            description='Total number of output files (only present for terminal states)'
        ),
    ] = None
    workflow_id: Annotated[
        str | None, Field(description='UUID identifying the workflow graph definition')
    ] = None


class JobDetailResponse(BaseModel):
    id: Annotated[UUID, Field(description='Unique job identifier')]
    status: Annotated[Status1, Field(description='User-friendly job status')]
    workflow: Annotated[
        dict[str, Any] | None, Field(description='Full ComfyUI workflow (10-100KB)')
    ] = None
    error_message: Annotated[
        str | None, Field(description='Error message if job failed')
    ] = None
    create_time: Annotated[
        int, Field(description='Job creation timestamp (Unix timestamp in seconds)')
    ]
    update_time: Annotated[
        int, Field(description='Last update timestamp (Unix timestamp in seconds)')
    ]
    outputs: Annotated[
        dict[str, Any] | None,
        Field(
            description='Full outputs object from ComfyUI (only for terminal states)'
        ),
    ] = None
    preview_output: Annotated[
        dict[str, Any] | None,
        Field(description='Primary preview output (only for terminal states)'),
    ] = None
    outputs_count: Annotated[
        int | None,
        Field(description='Total number of output files (only for terminal states)'),
    ] = None
    execution_status: Annotated[
        dict[str, Any] | None,
        Field(
            description='ComfyUI execution status and timeline (only for terminal states)'
        ),
    ] = None
    execution_meta: Annotated[
        dict[str, Any] | None,
        Field(description='Node-level execution metadata (only for terminal states)'),
    ] = None


class PaginationInfo(BaseModel):
    offset: Annotated[int, Field(description='Current offset (0-based)', ge=0)]
    limit: Annotated[int, Field(description='Items per page', ge=1)]
    total: Annotated[
        int, Field(description='Total number of items matching filters', ge=0)
    ]
    has_more: Annotated[
        bool, Field(description='Whether more items are available beyond this page')
    ]


class HistoryResponse(BaseModel):
    history: Annotated[
        list[HistoryEntry],
        Field(
            description='Array of history entries ordered by creation time (newest first)'
        ),
    ]


class UserDataResponse(RootModel[UserDataResponseFull | str]):
    root: UserDataResponseFull | str


class GetUserDataResponseFull(RootModel[list[GetUserDataResponseFullFile]]):
    root: list[GetUserDataResponseFullFile]


class ValidationResult(BaseModel):
    is_valid: Annotated[
        bool,
        Field(
            description='Overall validation status (true if all checks passed)',
            examples=[True],
        ),
    ]
    errors: Annotated[
        list[ValidationError] | None,
        Field(description='Blocking validation errors that prevent download'),
    ] = None
    warnings: Annotated[
        list[ValidationError] | None,
        Field(description='Non-blocking validation warnings (informational only)'),
    ] = None


class JobsListResponse(BaseModel):
    jobs: Annotated[
        list[JobEntry],
        Field(description='Array of jobs ordered by specified sort field'),
    ]
    pagination: PaginationInfo


class AssetMetadataResponse(BaseModel):
    content_length: Annotated[
        int,
        Field(
            description='Size of the asset in bytes (-1 if unknown)',
            examples=[4294967296],
        ),
    ]
    content_type: Annotated[
        str | None,
        Field(
            description='MIME type of the asset', examples=['application/octet-stream']
        ),
    ] = None
    final_url: Annotated[
        AnyUrl,
        Field(
            description='Final URL after following any redirects',
            examples=['https://civitai.com/download/model-file.safetensors'],
        ),
    ]
    filename: Annotated[
        str | None,
        Field(
            description='Suggested filename for the asset from source',
            examples=['realistic-vision-v5.safetensors'],
        ),
    ] = None
    name: Annotated[
        str | None,
        Field(
            description='Display name or title for the asset from source',
            examples=['Realistic Vision v5.0'],
        ),
    ] = None
    tags: Annotated[
        list[str] | None,
        Field(
            description='Tags for categorization from source',
            examples=[['models', 'checkpoint']],
        ),
    ] = None
    validation: Annotated[
        ValidationResult | None, Field(description='Validation results for the file')
    ] = None
